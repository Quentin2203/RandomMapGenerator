/***** PERLIN FUNCTIONS *****/

/**
 * Returns a//b
 * @param {int} a
 * @param {int} b
 */
function intDivision(a,b){
    /* Returns a//b */
    return (a-(a%b))/b;
}

/**
 * Returns a&b (bit to bit logical AND)
 * @param {int} a
 * @param {int} b
 */
function logicalAnd(a,b){
    /* a and b are int numbers.
    Returns the value of a&b */
    var result=0;
    var cp_a=a%256 , cp_b=b%256;
    for(var i=1 ; i<=8 ; i++){
        var a_byte = intDivision(cp_a,Math.pow(2,8-i));
        var b_byte = intDivision(cp_b,Math.pow(2,8-i));
        if(cp_a>=Math.pow(2,8-i)) cp_a -= Math.pow(2,8-i);
        if(cp_b>=Math.pow(2,8-i)) cp_b -= Math.pow(2,8-i);
        result += a_byte*b_byte*Math.pow(2,8-i);
    }
    return result;
}

/**
 * Turns a 256-long permutation table into a 512-long shuffled permutation table
 * @param {array} perm : the permutation table, which is a 1D array.
 */
function shufflePermTable(perm) {
    newPerm=[]
    for(var i=0 ; i<512 ; i++) {
        newPerm.push(perm[logicalAnd(i,255)]);
    }
    return newPerm;
}

/**
 * Randomly shuffles an array. It uses a "classical" randomization, and not a controlled randomization such as Perlin noise.
 * @param {array} array : the 1D array that we want to shuffle.
 */
function shuffleArray(array) {
    // Thanks stackoverflow!
    // https://stackoverflow.com/questions/6274339/how-can-i-shuffle-an-array
    var j, x, i;
    for (i = array.length - 1; i > 0; i--) {
        j = Math.floor(Math.random() * (i + 1));
        x = array[i];
        array[i] = array[j];
        array[j] = x;
    }
    return array;
}

/**
 * Returns the result of an interpolation based on a cosinusoidal function.
 * @param {float} t 
 */
function cosinusoidalInterpolation(t) {
    return (1-Math.cos(Math.PI*t))*0.5;
}

/**
 * Returns the result of an interpolation based on a cubic function.
 * @param {float} t 
 */
function cubicInterpolation(t) {
    return 3*Math.pow(t,2)-2*Math.pow(t,3);
}

/**
 * Returns the result of an interpolation based on a Perlin's function.
 * @param {float} t 
 */
function perlinInterpolation(t) {
    return 6*Math.pow(t,5)-15*Math.pow(t,4)+10*Math.pow(t,3);
}

/**
 * Returns the value of the value on coordinates (x,y) generated by a Perlin noise
 * @param {int} x : the x coordinate
 * @param {int} y : the y coordinate
 * @param {int} res : the resolution of the Perlin noise
 * @param {string} interpolation : the chosen interpolation function
 * @return the value in range [-1,1] generated by the Perlin noise
 */
function get2DPerlinNoiseValue(x,y,res,perm,interpolation){
    /* x , y : coordinates of the pixel
     res : resolution of the whole image */
    
    var tempX,tempY;
    
    // Unitary value of gradients length
    var unit = 1.0/Math.sqrt(2);
    
    //
    var tmp,s,t,u,v,Cx,Cy,iST,iUV;
    
    // Gradients array
    var gradients=[[unit,unit],[-unit,unit],[unit,-unit],[-unit,-unit],[1,0],[-1,0],[0,1],[0,-1]];
    
    // Adaptation for resolution
    x/=res;
    y/=res;
    
    // Coordinates of the top left corner of the "square" where is the pixel
    var x0=Math.floor(x) , y0=Math.floor(y);
    
    
    /* Récupération pseudo-aléatoire des gradients */
    var ii = logicalAnd(x0,255);
    var jj = logicalAnd(y0,255);
    var G1 = perm[ii+perm[jj]]%8        // Top left gradient
    var G2 = perm[ii+1+perm[jj]]%8      // Top right gradient
    var G3 = perm[ii+perm[jj+1]]%8      // Bottom right gradient
    var G4 = perm[ii+1+perm[jj+1]]%8    // Bottom leftt gradient
    
    // Top left
    tempX = x-x0;
    tempY = y-y0;
    s = gradients[G1][0]*tempX+gradients[G1][1]*tempY;
    
    /// Top right
    tempX = x-(x0+1);
    tempY = y-y0;
    t = gradients[G2][0]*tempX+gradients[G2][1]*tempY;
    
    // Bottom right
    tempX = x-x0;
    tempY = y-(y0+1);
    u = gradients[G3][0]*tempX+gradients[G3][1]*tempY;
    
    // Bottom left
    tempX = x-(x0+1);
    tempY = y-(y0+1);
    v = gradients[G4][0]*tempX+gradients[G4][1]*tempY;
    
    /* Interpolation
       Interpolation on x coordinates between s and t, then between v and u.
       Then, interpolation on y coordinates between iST and iUV.
       s---iST----t
       |    |     |
       |    p     |
       |    |     |
       |    |     |
       v---iUV----u
     */
    if(interpolation=="cosinusoidal") {
        tmp = x-x0;
        Cx = cosinusoidalInterpolation(tmp);
        iST = s+Cx*(t-s);
        iUV = u+Cx*(v-u);
        tmp = y-y0;
        Cy = cosinusoidalInterpolation(tmp);
    }
    else if(interpolation=="cubic") {
        tmp = x-x0;
        Cx = cubicInterpolation(tmp);
        iST = s+Cx*(t-s);
        iUV = u+Cx*(v-u);
        tmp = y-y0;
        Cy = cubicInterpolation(tmp);
    } else if (interpolation=="perlin") {
        tmp = x-x0;
        Cx = perlinInterpolation(tmp);
        iST = s+Cx*(t-s);
        iUV = u+Cx*(v-u);
        tmp = y-y0;
        Cy = perlinInterpolation(tmp);
    }
        
    return iST+Cy*(iUV-iST);
}

/**
 * Generates a 2D array by using a Perlin noise. This array will be used to create the whole map.
 * @param {int} width the width of the array, i.e the number of columns
 * @param {int} height the height of the array, i.e the number of rows
 * @param {int} res the resolution of the Perlin noise
 * @param {array} perm : the permutation table used by the noise
 * @param {string} interpolation : the chosen interpolation function
 * @return {array} perlinArray : a 2D array generated thanks to Perlin noise. We'll use it to display the map.
 */
function generatePerlinArray(width,height,res,perm,interpolation) {
    var perlinArray=[];
    for(var i=0 ; i<height ; i++) {
        var perlinArrayLine = [];
        for (var j=0 ; j<width ; j++) {
            var value=get2DPerlinNoiseValue(i,j,res,perm,interpolation);
            perlinArrayLine.push(value);
        }
        perlinArray.push(perlinArrayLine);
    }
    return perlinArray;
}


/**** MAP DRAWING *****/

/**
 * Generates a 2D array with specific dimension : array[height][width]
 * @param {int} width : "width" of the array, i.e the length of the 1D arrays contained in the array
 * @param {int} height : "height" of the array, i.e the number of 1D arrays contained in the array
 * @return {array} array : the initialized array
 */
function initArray(width,height) {
    var array = [];
    for (var j=0 ; j<height ; j++) {
        var arrayLine = [];
        for (var i=0 ; i<width ; i++) {
            arrayLine.push(0);
        }
        array.push(arrayLine);
    }
    return array;
}

/**
 * Returns the neighbours of the square which is on the y-th line and x-th column of the map that corresponds to the array.
 * The neihbours are the squares on the top, left, right or bottom of the square.
 * @param {array} array a 2D array that is here 
 * @param {int} x the x coordinates of the square
 * @param {int} y the y coordinates of the square
 * @return a 1D array that contains the neighbours of the square
 */
function getNeighbours(array,x,y) {
	var nbL = array.length,
		nbC = array.length[0];
	if (y == 0) {
		if (x == 0) return [array[y][x+1] , array[y+1][x]];
		else if (x == nbC - 1) return [array[y][x-1] , array[y+1][x]];
		else return [array[y][x-1] , array[y][x+1] , array[y+1][x]];
	} else if (y == nbL - 1) {
		if (x == 0) return [array[y][x+1] , array[y-1][x]];
		else if (x == nbC - 1) return [array[y][x-1] , array[y-1][x]];
		else return [array[y][x-1] , array[y][x+1] , array[y-1][x]];
	} else {
		if (x == 0) return [array[y-1][x] , array[y][x+1] , array[y+1][x]];
		else if (x == nbC - 1) return [array[y - 1][x] , array[y][x-1] , array[y+1][x]];
		else return [array[y-1][x] , array[y][x-1] , array[y][x+1] , array[y+1][x]];
	}
}

/**
 * Returns the neighbours of the square which is on the y-th line and x-th column of the map that corresponds to the array.
 * The neihbours are all the squares in direct contact around the square, diagonal contacts included.
 * @param {array} array a 2D array that is here 
 * @param {int} x the x coordinates of the square
 * @param {int} y the y coordinates of the square
 * @return a 1D array that contains the neighbours of the square
 */
function getAllNeighbours(array,x,y) {
	var nbL = array.length,
		nbC = array.length[0];
	if (y == 0) {
		if (x == 0) return [array[y][x + 1], array[y + 1][x], array[y + 1][x + 1]];
		else if (x == nbC - 1) return [array[y][x - 1], array[y + 1][x], array[y - 1][x - 1]];
		else return [array[y][x - 1], array[y][x + 1], array[y + 1][x - 1], array[y + 1][x], array[y + 1][x + 1]];
	} else if (y == nbL - 1) {
		if (x == 0) return [array[y][x + 1], array[y - 1][x], array[y - 1][x + 1]];
		else if (x == nbC - 1) return [array[y][x - 1], array[y - 1][x], array[y - 1][x - 1]];
		else return [array[y][x - 1], array[y][x + 1], array[y - 1][x - 1], array[y - 1][x], array[y - 1][x + 1]];
	} else {
		if (x == 0) return [array[y - 1][x], array[y - 1][x + 1], array[y][x + 1], array[y + 1][x], array[y + 1][x + 1]];
		else if (x == nbC - 1) return [array[y - 1][x], array[y - 1][x - 1], array[y][x - 1], array[y + 1][x], array[y + 1][x - 1]];
		else return [array[y - 1][x - 1], array[y - 1][x], array[y - 1][x + 1], array[y][x - 1], array[y][x + 1], array[y + 1][x - 1], array[y + 1][x], array[y + 1][x + 1]];
	}
}

/**
 * Determines if the square on coordinates (x,y) has at least one neighbour which is a water square.
 * @param {array} a 2D array that contains values in the range [-1,1]
 * @param {x} the x coordinates of the square
 * @param {y} the y coordinates of the square
 * @return {boolean} true if at least one of the neighbours of the square is water, false else.
 */
function nearOfWater(array,x,y) {
    if(array[y][x]<0) return false;
    var neighbours = getNeighbours(array,x,y);
    for(var k=0 ; k<neighbours.length ; k++) {
        if(neighbours[k]<0) {
            return true;
        }
    }
    return false;
}

/**
 * Initializes the list of authorized climates of the map, based on the checked climates on the form.
 */
function initClimatesList() {
    var climatesList = [];
    if(document.getElementById("grassCheckbox").checked)    climatesList.push("grass");
    if(document.getElementById("dryCheckbox").checked)      climatesList.push("dry");
    if(document.getElementById("mountainCheckbox").checked) climatesList.push("mountain");
    if(document.getElementById("snowCheckbox").checked)     climatesList.push("snow");
    if(document.getElementById("darkCheckbox").checked)     climatesList.push("dark");
    return climatesList;
}

/**
 * Generates a 2D array where is "drawn" on its center a circle with a specific radius.
 * @param {int} width the width, i.e number of columns, of the array
 * @param {int} height the height, i.e number of lines, of the array
 * @param {int} radius the radius of the circle
 * @return {array} circleArray the 2D array generated by the function.
 */
function createCircleArray(width,height,radius) {
    // Initialize the square
    var circleArray = [];
    for (var i=0 ; i<height ; i++) {
        var line = [];
        for (var j=0 ; j<width ; j++) {
            line.push(0.5);
        }
        circleArray.push(line);
    }
    var centerX = intDivision(height,2);
    var centerY = intDivision(width,2);
    var radiusStep = 0.25/radius;
    for (var rad=0; rad<radius ; rad++) {
        var value = rad*radiusStep;
        var angle = 0;
        while(angle < 360) {
            x = parseInt(centerX + rad * Math.cos(angle));
            y = parseInt(centerY + rad * Math.sin(angle));
            circleArray[x][y] = value;
            angle += 0.25;
        }
    }
    return circleArray;
}

/**
 * Generates a 2D array where is "drawn" from its center a radial gradient.
 * @param {int} width the width, i.e number of columns, of the array
 * @param {int} height the height, i.e number of lines, of the array
 * @param {int} limRadius the maximum radius where we can extend the gradient without overflow of the array.
 * @return {array} radialGradientArray the 2D array generated by the function.
 */
function createRadialGradientArray(width,height,limRadius) {
    // Initialize the square
    var radialGradientArray = [];
    var centerX = Math.floor(width/2);
    var centerY = Math.floor(height/2);
    var furthestDistanceFromCenter = Math.sqrt(Math.pow(0-centerX,2)+Math.pow(0-centerY,2));
    for (var y=0 ; y<height ; y++) {
        var line = [];
        for (var x=0 ; x<width ; x++) {
            var distanceFromCenter = Math.sqrt(Math.pow(x-centerX,2)+Math.pow(y-centerY,2));
            if(distanceFromCenter<=limRadius+2){
                line.push(0.25*Math.pow(distanceFromCenter/furthestDistanceFromCenter,4));
            } else {
                line.push(0.25*Math.pow(distanceFromCenter/furthestDistanceFromCenter,4));
            }
        }
        radialGradientArray.push(line);
    }
    return radialGradientArray;
}

/**
 * Crosses the fieldPerlinArray until it meets a square with a positive altitude, then identify its island thanks to the function identifyIsland,
 * then continues to crossesthe array until the end, identfying an island whenever it's necessary.
 * @param {array} fieldPerlinArray a 2D array that contains the altitudes of the differents squares, used to avoid drawing towns in water.
 */
function createIslandsArray(fieldPerlinArray) {
    var width = fieldPerlinArray[0].length , height = fieldPerlinArray.length;
    var islandsArray = initArray(width,height);
    var islandNum = 1;
    for(var y=0 ; y<height; y++) {
        for(var x=0 ; x<width ; x++) {
            square = squaresDatasArray[y][x];
            if(fieldPerlinArray[y][x]>=0) {
                if(islandsArray[y][x]==0){
                    islandsArray = identifyIsland(square,fieldPerlinArray,islandsArray,islandNum);
                    square.islandNum = islandNum;
                    islandNum++;
                }
            }
        }
    }
    return islandsArray;    
}

/**
 * When the different islands are identified thanks to the function createIslandsArray, some non-coherent values appear.
 * Those values are mostly values alone among other values. Example: the num on an island surrounded by 0s of the water.
 * @param {array} islandsArray a 2D array that contains integers. If this integer is 0, then the associated square is in the water.
 * Else, the integer is the num of the island where it is.
 */
function cleanIslandsArray(islandsArray) {
    var w=islandsArray[0].length , h=islandsArray.length;
    var cleanedIslandsArray = initArray(w,h);
    for (var y=0 ; y<h ; y++) {
        for (var x=0 ; x<w ; x++) {
            var testValue = islandsArray[y][x];
            var cleanValue = testValue;
            var neighbours = getAllNeighbours(islandsArray,x,y);
            var alone = true;
            for (var i=0 ; i<neighbours.length ; i++) {
                if(neighbours[i]==testValue && neighbours[i]!=-1) {
                    alone = false;
                }
            }
            if(alone) {
                cleanValue = neighbours[0];
            }
            cleanedIslandsArray[y][x] = cleanValue;
        }
    }
    return cleanedIslandsArray;
}

/**
 * Identify an island with a logic inspired by flood fill algorithms.
 * @param {SquareData} square the square of the map which is the beginning of the island
 * @param {array} fieldPerlinArray 2D array that contains the altitudes of the differents squares, used to avoid drawing towns in water.
 * @param {array} islandsArray 2D array that contains integers. If this integer is 0, then the associated square is in the water.
 * Else, the integer is the num of the island where it is.
 * @param {integer} islandNum the num of the identified island
 */
function identifyIsland(square,fieldPerlinArray,islandsArray,islandNum){
    // Step 1 : initialize the list nextNeighbours with the neighbours of the first square
    islandsArray[square.x][square.y]=islandNum;
    var firstNeighbours = getAllNeighbours(squaresDatasArray,square.x,square.y);
    var neighbours = [];
    for(var i=0; i<firstNeighbours.length;i++){
        square=firstNeighbours[i];
        if (islandsArray[square.y][square.x]==0 & square.altitude>=0){
            islandsArray[square.y][square.x]=islandNum;
            neighbours.push(square);
        }
    }
    // Step 2 : we continue while there's still neighbours
    while(neighbours.length>0) {
        var nextStepNeighbours = [];
        for (var k=0 ; k<neighbours.length ; k++) {
            square = neighbours[k];
            nextNeighbours = getAllNeighbours(squaresDatasArray,square.x,square.y);
            for (var i=0 ; i<nextNeighbours.length ; i++) {
                var n = nextNeighbours[i];
                if(islandsArray[n.y][n.x]==0 & n.altitude>=0) {
                    islandsArray[n.y][n.x]=islandNum;
                    nextStepNeighbours.push(n);
                }
            }
        }
        neighbours = nextStepNeighbours;
    }
    return islandsArray;
}

/**
 * Used during the creation of IslandDatas, to check if an island
 * is already created or not.
 * @param {integer} num the num of the island.
 */
function checkIslandData(num) {
    for(var i=0 ; i<islandsDatasArray.length ; i++) {
        if(islandsDatasArray[i].num==num) {
            return true;
        }
    }
    return false;
}

/**
 * Returns an IslandData after having found it thanks to its num
 * @param {integer} num : an integer that represents the num of the islands that we want to get.
 */
function getIslandByNum(num){
    for(var i=0 ; i<islandsDatasArray.length ; i++) {
        if(islandsDatasArray[i].num==num) {
            return islandsDatasArray[i];
        }
    }
    return null;
}

/**
 * Checks how many times value appears in array
 * @param {integer} value 
 * @param {array} array 
 */
function nbOccurencesIn2DArray(value,array) {
    var c=0;
    for (var y=0 ; y<array.length ; y++) {
        for (var x=0 ; x<array[y].length ; x++) {
            if(array[y][x]==value) {
                c++;
            }
        }
    }
    return c;
}

/**
 * Draws the different towns on the map.
 * @param {array} fieldPerlinArray 2D array that contains the altitudes of the differents squares, used to avoid drawing towns in water.
 * @param {array} islandsArray 2D array that contains integers. If this integer is 0, then the associated square is in the water.
 * Else, the integer is the num of the island where it is.
 */
function drawTownsOnMap(fieldPerlinArray,islandsArray) {
    townsDatasArray = [];
    var grassTownsNames = ["Tezhaël","Bosquet Bourg","Versentier","Algania","Florasia",
        "Troncreux","Feuilledor","Cité Suspendue","Farändhel","Azuria"];
    var dryTownsNames = ["Kylhos","Cité des Sables","Persicopia","Poussièrebourg","Îrmiz",
        "Haut-de-Dune","Farnest","Sècheterre","Lazaakh","Agathania"];
    var mountainTownsNames = ["Flanc-de-Crête","Village Haut-Perché","Cristalita","Percebrume","Elkhys",
        "Rocaria","Fort Granit","Bourg Boueux","Ruines argileuses","Refuge abandonné"];
    var snowTownsNames = ["Fort du Flocon","Valksberg","Halfjort","Aad Feljörn","Coupeglace",
        "Glaçonia","Ruines gelées","Lëëfh","Fjorda","Kryotopia"];
    var darkTownsNames = ["Bal-Dârug","Mornerive","Village des Cendres","Obscuria","Aabïs",
        "Forteresse des Crocs","Prison des Abysses","Ténébrume","Tour Biscornue","Faal-Doomh"];
    for(var c=1 ; c<=nbTowns ; c++) {
        var townX = Math.floor(fieldPerlinArray[0].length*Math.random());
        var townY = Math.floor(fieldPerlinArray.length*Math.random());
        while(fieldPerlinArray[townY][townX]<0) {
            townX = Math.floor(fieldPerlinArray[0].length*Math.random());
            townY = Math.floor(fieldPerlinArray.length*Math.random());
        }
        var islandNum = islandsArray[townY][townX];
        var island = getIslandByNum(islandNum);
        var climate = island.climate;
        var name = "" , color="";
        var randIndex = 0;
        switch(climate) {
            case "grass":        
                if(townsNamed) {
                    randIndex = Math.floor(Math.random()*grassTownsNames.length);        
                    name = grassTownsNames[randIndex];
                    grassTownsNames.splice(randIndex,1);
                }
                color = "darkgreen";
                break;
            case "dry":          
                if(townsNamed) {
                    randIndex = Math.floor(Math.random()*dryTownsNames.length);                  
                    name = dryTownsNames[randIndex];
                    dryTownsNames.splice(randIndex,1);
                }
                color = "gold";
                break;
            case "mountain":    
                if(townsNamed) {
                    randIndex = Math.floor(Math.random()*mountainTownsNames.length);
                    name = mountainTownsNames[randIndex];
                    mountainTownsNames.splice(randIndex,1);
                }   
                color = "brown";
                break;
            case "snow":        
                if(townsNamed) {
                    randIndex = Math.floor(Math.random()*snowTownsNames.length);
                    name = snowTownsNames[randIndex];
                    snowTownsNames.splice(randIndex,1);
                }
                color = "dodgerblue";
                break;
            case "dark":        
                if(townsNamed) {
                    randIndex = Math.floor(Math.random()*darkTownsNames.length);
                    name = darkTownsNames[randIndex];
                    darkTownsNames.splice(randIndex,1);
                }
                color = "black";
                break;
        }
        var town = Object.create(TownData);
        town.init(townX,townY,name,squareSize);
        townsDatasArray.push(town);
        canvasCtx.beginPath();
        canvasCtx.fillStyle = color;
        canvasCtx.arc(
            town.x*squareSize+0.5*squareSize,    // Center X
            town.y*squareSize+0.5*squareSize,    // Center Y
            town.radius,      // Radius
            0,      // Start angle
            2*Math.PI   // End angle
        );
        canvasCtx.fill();
        canvasCtx.closePath();
    }
    if(townsNamed) {
        for(var i=0 ; i<townsDatasArray.length ; i++){
            // Name of the town
            var town = townsDatasArray[i];
            var fontSize = 2*squareSize;
            if(fontSize<12) fontSize = 12;
            canvasCtx.font = fontSize+"px Arial";
            canvasCtx.textAlign = "center";
            canvasCtx.fillStyle="black";
            nameX = town.x;
            nameY = town.y;
            canvasCtx.fillText(
                town.name,
                nameX*squareSize,
                nameY*squareSize-squareSize*0.5-5
            );
        }
    }
}

/**
 * Draw a square on the map.
 * @param {integer} x coordinate of the square in the map
 * @param {integer} y y coordinate of the square in the map
 * @param {array} fieldPerlinArray a Perlin 2D-array that contains the value for altitudes
 * @param {array} itemsPerlinArray a Perlin 2D-array that contains the value for items
 */
function drawCanvasSquare(squareData) {
    var x = squareData.x;
    var y = squareData.y;
    var altitude=squareData.altitude;
    var isBeach = squareData.nearOfWater;
    var color = [];
    if(altitude<0) {
        // Water square
        if(altitude>-altitudeFactor) {
            var altitudeIndex = intDivision(Math.abs(altitude),intDivision(altitudeFactor,5));
        }
        else if (altitude==-altitudeFactor) {
            var altitudeIndex=ground.length-1;
        }
        color = water[altitudeIndex];
        color="rgb("+color.join(',')+")";
    }
    else {
        // Field square
        if(altitude<altitudeFactor) {
            var altitudeIndex = intDivision(altitude,altitudeStep);
        }
        else if(altitude==altitudeFactor) {
            var altitudeIndex = intDivision(altitudeFactor,altitudeStep)-1;
        }
        var climate = "";
        if(squareData.islandNum>0) climate = getIslandByNum(squareData.islandNum).climate;
        if(isBeach) {
            switch(climate){
                case "dark":
                    color = [192,192,192]; // Silver
                    break;
                case "snow":
                    color = [219,240,253];
                    break;
                default:
                    color = sand;
                    break;
            }
            isBeach = true;
        } else {
            switch(climate){
                case "grass":
                    color = grass[altitudeIndex];
                    break;
                case "dry":
                    color = dry[altitudeIndex];
                    break;
                case "mountain":
                    color = mountain[altitudeIndex];
                    break;
                case "snow":
                    color = snow[altitudeIndex];
                    break;
                case "dark":
                    color = dark[altitudeIndex];
                    break;
                default:
                    color = grass[altitudeIndex];
                    break;
            }
        }
        color="rgb("+color.join(',')+")";
    }
    canvasCtx.fillStyle=color;
    canvasCtx.fillRect(x*squareSize,y*squareSize,squareSize,squareSize);
}

/**
 * Draws the map square by square. 
 * Note: returns nothing, but dynamically modify the HTML element that corresponds to the map.
 * @param {integer} width : the width (number of columns) of the map
 * @param {integer} height : the height (number of lines) of the map
 * @param {integer} res : the resolution of the Perlin noise that allows to generate the map
 * @param {string} interpolation : the chosen interpolation function
 */
function generateCanvasMap(width,height,res,interpolation) {
    var titleHeight = 60;
    canvas.width = width*squareSize;
    canvas.height = height*squareSize+titleHeight;
    squaresDatasArray = [];
    islandsDatasArray = [];
    townsDatasArray = [];
    
    /* A Perlin array for the relief */
    perm = shuffleArray(perm);
    var fieldPerlinArray = generatePerlinArray(width,height,res,perm,interpolation);
    /* A Perlin array that we'll refer to for placing items (trees, houses,...) on the map */
    perm = shuffleArray(perm);
    var itemsPerlinArray = generatePerlinArray(width,height,10,perm,interpolation);
    /* A radial gradient 2D array */
    var radius = Math.min(intDivision(width,2)-3,intDivision(height,2)-3);
    var radialGradientArray = createRadialGradientArray(width,height,radius);
    var centerX = intDivision(fieldPerlinArray[0].length,2);
    var centerY = intDivision(fieldPerlinArray.length,2);
    
    /* Using the radial gradient to create islands */
    for(var y=0 ; y<fieldPerlinArray.length ; y++) {
        //We are on the y-th line
        for(var x=0 ; x<fieldPerlinArray[0].length ; x++) {
            //We are on the x-th column
            var testRadius = Math.sqrt(Math.pow(x-centerX,2)+Math.pow(y-centerY,2));
            fieldPerlinArray[y][x]-=radialGradientArray[y][x];
            if(fieldPerlinArray[y][x]<-1) fieldPerlinArray[y][x]=-1;
            if(fieldPerlinArray[y][x]>1) fieldPerlinArray[y][x]=1;
            if(testRadius>=radius) {
                if(fieldPerlinArray[y][x]<0) {
                    fieldPerlinArray[y][x] = fieldPerlinArray[y][x];
                }
                else if (fieldPerlinArray[y][x]==0) {
                    fieldPerlinArray[y][x] = -0.05;
                }
                if(fieldPerlinArray[y][x]>0) {
                    fieldPerlinArray[y][x] -= radialGradientArray[y][x];
                    if(fieldPerlinArray[y][x]>0) {
                        fieldPerlinArray[y][x]*=-1/2;
                    }
                }
                if(fieldPerlinArray[y][x]>1) fieldPerlinArray[y][x]=1;
                if(fieldPerlinArray[y][x]<-1) fieldPerlinArray[y][x]=-1;
            }
        }
    }
    
    /* Generating the squares of the map */
    for(var y=0 ; y<fieldPerlinArray.length ; y++) {
        var squaresDatasArrayLine = [];
        for(var x=0 ; x<fieldPerlinArray[y].length ; x++) {
            var squareData = Object.create(SquareData);
            var altitude = fieldPerlinArray[y][x]*altitudeFactor;
            var islandNum = -1;
            var isBeach = nearOfWater(fieldPerlinArray,x,y);
            squareData.init(x,y,altitude,isBeach,islandNum);
            squaresDatasArrayLine.push(squareData);
        }
        squaresDatasArray.push(squaresDatasArrayLine);
    }
    
    /* Distinguishing the differents islands */
    var islandsArray = cleanIslandsArray(createIslandsArray(fieldPerlinArray));
    for(var y=0 ; y<islandsArray.length; y++){
        for(var x=0 ; x<islandsArray[y].length ; x++) {
            var value = islandsArray[y][x];
            canvasCtx.font="normal "+Math.floor(squareSize/2)+"px Arial";
            //canvasCtx.strokeText(value,x*squareSize+(squareSize/2),y*squareSize+(squareSize/2));
            if(value>0) {
                var islandBool = checkIslandData(value);
                if(!islandBool) {
                    var islandData = Object.create(IslandData);
                    var climateRandIndex = Math.floor(Math.random()*climatesList.length);
                    if(climateRandIndex>=climatesList.length){
                        climateRandIndex = climatesList-1;
                    }
                    var climate=climatesList[climateRandIndex];
                    islandData.init(value,"",1,climate);
                    islandsDatasArray.push(islandData);
                }
            }
        }
    }

    var grassIslandsNames = ["des Bosquets Chantants","Verdoyante","des Roses","de la Mousse Tiède","Forestière",
    "des Pinsons Piailleurs","aux Pins Chatoyants","du Camélia Chantant","de la Prairie Luxuriante","des Lianes Dansantes"];
    var dryIslandsNames = ["Désséchée","Froissée","de la Pluie Exilée","des Naufragés","des Vents Secs",
    "Aride","de la Poussière","Sableuse","Craquelée","des Steppes Venteuses"];
    var mountainIslandsNames = ["de la Terre Rouge","du Feu","des Roches Assoupies","Montagneuse","des Cailloux Taciturnes",
    "de la Vouivre Flamboyante","des Blocs de Granit","des Monts Perceurs de Nuage","aux Lézards Sifflotants","Minérale"];
    var snowIslandsNames = ["du Grand Froid","des Engelures","des Guerriers du Nord","du Flocon Fuyard","du Zéro Absolu",
    "du Blizzard Gémissant","aux Crevasses Embusquées","des Bourrasques Mordantes","de la Poudreuse Soyeuse","Verglacée"];
    var darkIslandsNames = ["des Ténèbres","des Squelettes ","Cendreuse","des Seigneurs du Mal","Brûlée",
    "des Landes Mornes","du Désespoir","des Piles de Crânes","Déchue","du Roi Fou"];

    for (var i=0 ; i<islandsDatasArray.length ; i++) {
        var island = islandsDatasArray[i];
        island.area = nbOccurencesIn2DArray(islandsDatasArray[i].num,islandsArray);
        /*Naming the island */
        var adj = "";
        switch(island.climate){
                case "grass":
                    var randNameIndex = Math.floor(Math.random()*grassIslandsNames.length);
                    adj = grassIslandsNames[randNameIndex];
                    grassIslandsNames.splice(randNameIndex,1);
                    break;
                case "dry":
                    var randNameIndex = Math.floor(Math.random()*dryIslandsNames.length);
                    adj = dryIslandsNames[randNameIndex];
                    dryIslandsNames.splice(randNameIndex,1);
                    break;
                case "mountain":
                    var randNameIndex = Math.floor(Math.random()*mountainIslandsNames.length);
                    adj = mountainIslandsNames[randNameIndex];
                    mountainIslandsNames.splice(randNameIndex,1);
                    break;
                case "snow":
                    var randNameIndex = Math.floor(Math.random()*snowIslandsNames.length);
                    adj = snowIslandsNames[randNameIndex];
                    snowIslandsNames.splice(randNameIndex,1);
                    break;
                case "dark":
                    var randNameIndex = Math.floor(Math.random()*darkIslandsNames.length);
                    adj = darkIslandsNames[randNameIndex];
                    darkIslandsNames.splice(randNameIndex,1);
                    break;   
                default:
                    break;
        }

        if(island.area<=50){
            island.name = "Îlot "+adj;
        } else {
            island.name = "Île "+adj;
        }
    }
    
    /* Drawing the map square by square */
    for(var y=0 ; y<squaresDatasArray.length ; y++) {
        for(var x=0 ; x<squaresDatasArray[y].length ; x++) {
            var squareData = squaresDatasArray[y][x];
            squareData.islandNum = islandsArray[y][x];
            drawCanvasSquare(squareData);
        }
    }
    
    /* Drawing the towns randomly on the map */
    drawTownsOnMap(fieldPerlinArray,islandsArray);
    
    canvas.addEventListener("click",function(event){
        var x = Math.floor((event.pageX - canvas.offsetLeft)/squareSize)-1; 
        var y = Math.floor((event.pageY - canvas.offsetTop)/squareSize)-1;
        var islandName = "";
        if(y<height){
            var squareData = squaresDatasArray[y][x];
            /* Island name */
            var clickValue=islandsArray[y][x];
            var islandNameSpan = document.getElementById("islandNameSpan");
            if(clickValue>0) {
                islandName = getIslandByNum(clickValue).name;
                islandNameSpan.textContent = islandName;
            } else {
                islandName = "L'Océan";
                islandNameSpan.textContent = islandName;
            }
            /* Field type */
            var fieldTypeSpan = document.getElementById("fieldTypeSpan");
            if(clickValue>0) {
                if(squareData.nearOfWater) {
                    fieldTypeSpan.textContent = "Plage";
                    document.getElementById("squareInfoDiv").style.backgroundColor = "#f2d16b";
                } else {
                    var fieldType = getIslandByNum(squareData.islandNum).climate;
                    switch(fieldType){
                        case "grass":
                            document.getElementById("squareInfoDiv").style.backgroundColor = "#31c831";
                            fieldTypeSpan.textContent = "Herbe";
                            break;
                        case "mountain":
                            document.getElementById("squareInfoDiv").style.backgroundColor = "#cd853f";
                            fieldTypeSpan.textContent = "Montagne";
                            break;
                        case "dry":
                            document.getElementById("squareInfoDiv").style.backgroundColor = "#c8ba8d";
                            fieldTypeSpan.textContent = "Friches / Désert";
                            break;
                        case "snow":
                            document.getElementById("squareInfoDiv").style.backgroundColor = "#cfebfd";
                            fieldTypeSpan.textContent = "Neige";
                            break;
                        case "dark":
                            document.getElementById("squareInfoDiv").style.backgroundColor = "#a9a9a9";
                            fieldTypeSpan.textContent = "Terres du Mal";
                            break;
                        default:
                            fieldTypeSpan.textContent = "";
                            break;
                    }
                }
            } else {
                document.getElementById("squareInfoDiv").style.backgroundColor = "#0066ff";
                fieldTypeSpan.textContent = "Eau";
            }
            /* Coordinates */
            var coordinatesSpan = document.getElementById("coordinatesSpan");
            coordinatesSpan.textContent="X="+x+" , Y="+y;
            /* Altitude */
            var altidudeSpan = document.getElementById("altitudeSpan");
            altitudeSpan.textContent = squareData.altitude.toFixed(2)+" m";
        }
        
        /* Click on a town */
        for(var i=0 ; i<townsDatasArray.length ; i++) {
            var canvasX = event.pageX - canvas.offsetLeft;
            var canvasY = event.pageY - canvas.offsetTop;

            var currentTownData = townsDatasArray[i];
            var centerTownX = parseInt(currentTownData.x)*parseInt(squareSize)+parseInt(squareSize);
            var centerTownY = parseInt(currentTownData.y)*parseInt(squareSize)+parseInt(squareSize);


            var distToCurrentTownCenter = Math.sqrt(Math.pow(canvasX-centerTownX,2)+Math.pow(canvasY-centerTownY,2));
            
            if(distToCurrentTownCenter<=currentTownData.radius*2) {
                document.getElementById("islandNameSpan").textContent += (" - "+currentTownData.name);
            }else {
                document.getElementById("islandNameSpan").textContent = islandName;
            }
        }
    });
    
    /* Naming the map */
    if(islandsDatasArray.length>1){
        var archipelagoesNames = ["du Dragon Azuré","du Silence","de la Nuit","du Bout du Monde","Solitaire",
            "des Îles Chamailleuses","Perdu","des Confins","Mélancolique","Méridional",
            "égaré dans la Brume","au Ciel d'Azur"];
        var randArchipelagoIndex = Math.floor(Math.random()*archipelagoesNames.length);
        if(randArchipelagoIndex>=archipelagoesNames.length){
            randArchipelagoIndex = archipelagoesNamess.length-1;
        }
        mapName = "Archipel "+archipelagoesNames[randArchipelagoIndex];
    } else {
        mapName = islandsDatasArray[0].name;
    }
    
    /* Drawing the title of the map */
    // The background
    canvasCtx.fillStyle = "beige"; 
    canvasCtx.fillRect(0,canvas.height-titleHeight,canvas.width,titleHeight);
    canvasCtx.strokeStyle = "black";
    canvasCtx.lineWidth = 1;
    canvasCtx.beginPath();
    canvasCtx.moveTo(0,canvas.height-titleHeight);
    canvasCtx.lineTo(canvas.width,canvas.height-titleHeight);
    canvasCtx.lineTo(canvas.width,canvas.height);
    canvasCtx.lineTo(0,canvas.height);
    canvasCtx.lineTo(0,canvas.height-titleHeight);
    canvasCtx.stroke();
    canvasCtx.closePath();
    // The text content
    var fontSize = 40;
    if(canvas.width-20<mapName.length*fontSize*0.5) {
        fontSize = (canvas.width-60)/(mapName.length*0.5);
    }
    canvasCtx.textAlign = "center";
    canvasCtx.font = fontSize+"px Arial";
    canvasCtx.fillStyle = "black";
    canvasCtx.fillText(mapName,canvas.width/2,canvas.height-(titleHeight/2-15));
    canvasCtx.textAlign = "start";

}



/*** MAIN PROGRAM ***/

/*** Perlin noise variables ***/

/* Permutation table */
var perm = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,
    142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,
    203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,
    74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,
    105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,
    187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,
    64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,
    47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,
    153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,
    112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,
    235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,
    127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,
    156,180];
perm = shufflePermTable(perm);  // Initial shuffle
    

/*** Map drawing variables ***/

/* SquaraData objects */
var SquareData = {
    init:function(x,y,altitude,nearOfWater,islandNum){
        this.x = x;
        this.y = y;
        this.altitude = altitude;
        this.nearOfWater = nearOfWater;
        this.islandNum = islandNum;
    }
};
var squaresDatasArray = [];

/* IslandData objects */
var IslandData = {
    init:function(num,name,area,climate){
        this.num = num;
        this.name = name;
        this.area = area;
        this.climate = climate;
    }
};
var islandsDatasArray = [];

/* Colors used on the map */
var water = [
    [0,102,255],    // #0066ff
    [0,82,204],     // #0052cc
    [0,61,153],     // #003d99
    [0,41,102],     // #002966
    [0,20,51]       // #001433
];
var sand = [242,209,107];   // f2d16b
var grass = [
    [49,200,49],    // #31c831
    [44,180,44],    // #2cb42c
    [39,159,39],    // #279f27
    [34,139,34],    // #228b22
    [29,119,29],    // #1d771d
];
var dry = [
    [200,186,141],  // #c8ba8d
    [194,178,128],  // #c2b280
    [188,170,115],  // #bcaa73
    [182,162,102],  // #b6a266
    [176,154,89]    // #b09b59
    
];
var mountain = [
    [205,133,63],   // #cd853f peru
    [210,105,30],   // #d2691e chocolate
    [160,82,45],    // #a0522d saddlebrown
    [139,69,19],    // #8b4513 sienna
    [165,42,42]     // #a52a2a brown
];
var snow = [
    [207,235,253],  // #cfebfd
    [195,230,252],  // #c3e6fc
    [187,225,252],
    [179,220,251],
    [171,215,251]
];
var dark = [
    [169,169,169],  // #a9a9a9 darkgrey
    [128,128,128],  // #808080 grey
    [105,105,105],  // #696969 dimgrey
    [82,82,82],
    [59,59,59]
];

var climatesList = initClimatesList();

var altitudeFactor = 300;
var altitudeStep = intDivision(altitudeFactor,dry.length);

var mapName = "";

/* The canvas */
var canvas = document.getElementById("canvas");
var canvasCtx = canvas.getContext('2d');

/* TownDatas objects */
var TownData ={
    init:function(x,y,name,radius){
        this.x = x;
        this.y = y;
        this.name = name;
        this.radius = radius;
    }
};
var townsDatasArray = [];

/* Interpolation functions */
var COSINUSOIDAL="cosinusoidal" , CUBIC="cubic", PERLIN="perlin";

/* Initial generation of the map and display of the generation time */
var nbRowsInput = document.getElementById("nbRowsInput");
var nbColumnsInput = document.getElementById("nbColumnsInput");
var resolutionInput = document.getElementById("resolutionInput");
var squareSizeInput = document.getElementById("squareSizeInput");
var nbTownsInput = document.getElementById("nbTownsInput");
var townsNamedInput = document.getElementById("townsNamedInput");

var initWidth = nbColumnsInput.value,
    initHeight = nbRowsInput.value,
    initRes = resolutionInput.value,
    squareSize = parseInt(squareSizeInput.value),
    nbTowns = nbTownsInput.value,
    townsNamed = townsNamedInput.checked,
    squareSize = squareSizeInput.value;


/*** The main function ***/
function main() {
    // Displaying the limits of the number inputs of the form
    document.getElementById("nbRowsLim").textContent = "("+nbRowsInput.min+"-"+nbRowsInput.max+")";
    document.getElementById("nbColumnsLim").textContent = "("+nbColumnsInput.min+"-"+nbColumnsInput.max+")";
    document.getElementById("resolutionLim").textContent = "("+resolutionInput.min+"-"+resolutionInput.max+")";
    document.getElementById("squareSizeLim").textContent = "("+squareSizeInput.min+"-"+squareSizeInput.max+")";
    document.getElementById("nbTownsLim").textContent = "("+nbTownsInput.min+"-"+nbTownsInput.max+")";

    // Generation of the map
    var start = Date.now();
    generateCanvasMap(initWidth,initHeight,initRes,PERLIN);
    var end = Date.now();

    // Displaying  the generation time of the map
    if(end-start<1000) {
        document.getElementById("generationTime").textContent=(end-start)+" ms";
    } else {
        document.getElementById("generationTime").textContent=((end-start)/1000)+" s";
    }

    // Adding the event listener of the button who generates the map
    var mapBtn = document.getElementById("mapBtn");
    mapBtn.addEventListener("click",function(e){

        e.preventDefault();

        initWidth = nbColumnsInput.value;
        initHeight = nbRowsInput.value;
        initRes = resolutionInput.value;
        squareSize = parseInt(squareSizeInput.value);
        nbTowns = nbTownsInput.value;
        townsNamed = townsNamedInput.checked;
        squareSize = squareSizeInput.value;

        climatesList = initClimatesList();
        
        var start = Date.now();
        generateCanvasMap(initWidth,initHeight,initRes,PERLIN);
        var end = Date.now();
        if(end-start<1000) {
            document.getElementById("generationTime").textContent=(end-start)+" ms";
        } else {
            document.getElementById("generationTime").textContent=((end-start)/1000)+" s";
        }
    });

    var saveMapBtn=document.getElementById("saveMapBtn");
    saveMapBtn.addEventListener("click",function(){
        saveMapBtn.download = mapName+".png";
        saveMapBtn.href = canvas.toDataURL("image/png");
    });
}

main();